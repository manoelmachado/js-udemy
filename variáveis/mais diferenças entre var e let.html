<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Diferenças entre LET e VAR:</h1>
    <a href="script.js">Execerícios</a>
    <p>let nome = 'Manoel'; <br>
        var nome = 'Manoel';</p>
    <p>Let e var ambas criam uma variável como já foi explicado anteriormente, mas qual a diferença entre elas?</p>
    <p>Uma das diferenças é que não podemos redeclarar a variável let. Como já declaramos o valor 'Manoel' à variável let, não podemos redefinir usando let nome = 'Lucas'; por exemplo. Já usando o var, conseguimos normalmente redefinir o valor usando var nome = 'Lucas'; e isso funcionaria normalmente.</p>
    <hr>
    <p>Outra diferença é sobre o escopo:</p>
    <h2>Escopo let:</h2>
        <p>Let é agora a forma preferida de declaração de variáveis. Não é uma surpresa, já que ele é uma melhoria às declarações com var. Ele também resolve o problema de var do qual acabamos de tratar. Vamos ver a razão disso.</p>
        <h3>let tem escopo de bloco</h3>
        <p>Um bloco é uma porção de código cercado por {}. Um bloco vive dentro dessas chaves. tudo o que estiver cercado por chaves é um bloco.</p>
        <p>Assim, uma variável declarada com let em um bloco estará disponível apenas dentro daquele bloco. Vamos explicar isso com um exeplo:</p>
        <p>
            let greeting = "say hi"; <br>
            let times = 4;<br>
            if (times > 3) { <br> 
            let hello = "say hello instead" <br>
            console.log(hello); // dirá "say hello instead" <br>
            } <br>
            console.log(hello) // hello não está definido
        </p>
        <p>Vemos que o uso de hello fora de seu bloco 9as chaves dentro das quais a variável foi definida) retorna um erro. Isso ocorre porque as variáveis de let tem escopo de bloco.</p>

        <h3>let pode ser atualizado, mas não declarado novamente.</h3>
        <p>Assim como var, uma variável declarada com let pode ser atualizada dentro de seu escopo. Diferente de var, no entanto, uma variável let não pode ser declarada novamente dentro de seu escopo. O código a seguir funciona:</p>
        <p>let greeting = "say hi"; <br>
            greeting = "say hello instead";
        </p>
        <p>Este outro código, no entando, retornará um erro:</p>
        <p>let greeting = "say hi"; <br>
            let greeting = "say Hello instead" // erro: identificador 'greeting' já foi declarado
        </p>
        <p>Porém, se a mesma variável for definida em escopos diferentes, não haverá erro:</p>
        <p>let greeting = "say hi; <br>
        if (true) { <br>
            let greeting = "say Hello instead"; <br>
            console.log(greeting); // retornará "say Hello instead" <br>
        } <br>
        console.log(greeting); // retornará "say Hi"; <br>
        </p>
        <p>Por que isso não retorna um erro? Porque as duas instâncias são tratadas como variáveis diferentes, já que são de escopos diferentes.</p>
        <p>Este fato torna o let uma escolha melhor do que var. Ao usar let, você não precisa se preocupar se usou o nome para uma variável antes, já que a variável existe somente dentro daquele escopo.</p>
        <p>Além disso, como uma variável não pdoe ser declarada mais de uma vez dentro de um escopo, o problema que ocorre com var que discutimos antes não acontece.</p>
        <h3>Hoisting de let</h3>
        <p>Assim como as declarações com var, as feitas com let também sofrem o hoisting para o topo. idferentemente de var, porém, que é inicializado como undefined, a palavra-chave let não é inicializada. Assim, se você tentar usar uma variável let antes de sua declaração, terá um Reference Error.</p>








    <h2>Escopo var:</h2>
        <p>Var tem escopo global ou de local/função. O escopo é global quando uma variável var é declarada fora de uma função. Isso significa que qualquer variável que seja declarada com var fora de um bloco de função pode ser utilizada na janela inteira.</p>
        <p>Var tem escopo de função quando é declarado dentro de uma função. Isso significa que ele está disponível e opde ser acessado somente de dentro daquela função.</p>
        <p>Para entender melhor, veja o exemplo abaixo:</p>
        <p>var greeter = "hey hi"; <br>
        function newFunction() { <br>
            var hello = "hello"; <br>
        }        </p>
        <p>Aqui, greeter tem um escopo global, pois existe fora de uma função, enquanto hello tem escopo de função. Por isso não podemos acessar a variável hello fora de uma fun~çao. Assim, se fizermos isso:</p>
        <p>var tester = "hey hi"; <br>
        function newFunction() { <br>
            var hello = "hello"; <br>
        } <br>
        console.log(hello); // erro: hello não está definido
        </p>
        <h3>Variáveis de var podem ser declaradas de novo e atualizadas. Isso significa que é possível fazer o seguinte dentro do mesmo escopo e não gerar um erro:</h3>
        <p>var greeter = "hey hi"; <br>
        var greeter = "say Hello instead";
        </p>
        <p>Ou isso:</p>
        <p>var greeter = "hey hi"; <br>
            greeter = "say Hello instead";
        </p>
        <h3>Hoisting de var:</h3>
        <p>Hoisting é um mecanismo do JavaScript que faz com que as declarações de variáveis e de funções sejam movidas para o topo de seu escopo antes da execução do código. Portanto, se fizermos isso:</p>
        <p>console.log(greeter); <br>
            var greeter = "say hello"; <br>
        </p>
        <p>A interpretação será:</p>
        <p>var greeter ; <br>
            console.log(greeter); // greeter is undefined <br>
            greeter = "say hello";
        </p>
        <p>Desse modo, variáveis de var sofrem o hoisting e vão para o topo do escopo, sendo inicializadas com um valor de undefined.</p>
        <h3>Problema com var:</h3>
        <p>Há um ponto fraco no uso de var. Usarei o exemplo abaixo para explicar:</p>
        <p>var greeter = "hey hi"; <br>
            var times = 4; <br>
            if (times > 3) { <br>
                var greeter = "say Hello instead"; <br>
            } <br>
            console.log(greeter) // o resultado será "say Hello instead"
        </p>
        <p>Assim, já que times > 3 retorna true, greeter é redefinido como "say Hello instead". Embora isso não seja um problema se você quer, conscientemente, que greeter possa ser redefinido, passará a ser um problema quando você não perceber que uma variável greeter já havia sido definida antes.</p>
        <p>Se você já usou greeter em outras partes do seu código, pode se surpreender com o resultado que vai obter. Isso provavelmente causará vários bugs no seu código. É por isso que let e const são necessários.</p>


</body>
</html>